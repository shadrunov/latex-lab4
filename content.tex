\section{Задание на практическую работу}
Целью данной работы является исследование асимметричной криптосистемы RSA, основанной на проблеме факторизации целых чисел.

В рамках практической работы необходимо выполнить следующее:
\begin{enumerate}
    \item Написать программную реализацию криптосистемы RSA;
    \item Изучить методы криптоанализа криптосистемы RSA;
    \item Реализовать (вручную или программно) не менее одной атаки на криптосистему RSA, исключая наивную переборную атаку, для случая, когда параметры криптосистемы не являются большими числами;
    \item Подготовить отчет о выполнении работы.
\end{enumerate}
\newpage




\section{Краткая теоретическая часть}
\subsection{Криптография с открытым ключом}
Концепция криптографии с открытым ключом появилась в середине 1970-х годов как возможное решение проблемы распределения ключей шифрования, актуальной для симметричных алгоритмов шифрования. Отправной точкой для развития этой области можно считать публикацию статьи М. Хеллмана и У. Диффи "Новые направления в криптографии" \cite{crypto:dh}. 

Криптосистемы с открытым ключом, также называемые асимметричными криптосистемами, используют два разных ключа: открытый ключ зашифрования и закрытый ключ расшифрования. Открытый ключ в общем случае доступен всем желающим, а закрытый ключ известен только законному владельцу. Оба ключа связаны между собой некоторой математической зависимостью. При этом данная зависимость такова, что, зная один ключ, вычислить другой практически невозможно.
Первые криптографические алгоритмы с открытым ключом основаны на задаче факторизации целых чисел. Примеры других сложных вычислительных задач — вычисление логарифма в конечном поле и вычисление корней алгебраических уравнений.

\subsection{Криптосистема RSA}
Данная криптосистема является первой криптосистемой с открытым ключом. Она основывается на сложности проблемы факторизации целых чисел, то есть разложении чисел на простые множители.

\subsubsection*{Алгоритм генерации ключей}
\begin{enumerate}
    \item Пользователь A генерирует два больших простых числа $p$ и $q$, отличных друг от друга. При этом $|p-q|$ —  большое число, хотя $p$ и $q$ имеют приблизительно одинаковый битовый размер.
    \item Держа $p$ и $q$ в секрете, пользователь A вычисляет их произведение $n = p \cdot q$, которое называют \textit{модулем алгоритма}.
    \item Пользователь A вычисляет значение функции Эйлера для $n$ по формуле: \begin{align*}
        \phi(n) = (p-1)(q-1).
    \end{align*}
    \item Пользователь A выбирает целое число $e$, взаимно простое со значением функции $\phi(n)$. Это число называется \textit{экспонентой зашифрования}.
    \item Пользователь A применяет расширенный алгоритм Евклида к паре чисел $e$ и $\phi(n)$ и вычисляет значение $d$, удовлетворяющее соотношению $e \cdot d \equiv 1 \ mod \ \phi(n)$. Это значение называется \textit{экспонентой расшифрования}.
    \item Пара $(e, n)$ публикуется в качестве открытого ключа пользователя A;  $d$ является закрытым ключом и держится в секрете.
\end{enumerate}

\subsubsection*{Алгоритм зашифрования}
\begin{enumerate}
    \item Пользователь B получает аутентичную копию открытого ключа пользователя A — пару $(e, n)$.
    \item Пользователь B представляет сообщение в виде числа $m$, меньшего модуля алгоритма. В общем случае сообщение может быть разбито на блоки, каждый из которых представляется своим числом.
    \item Пользователь B вычисляет $c = m^e \ mod \ n$.
    \item Зашифрованное сообщение отправляется пользователю A.
\end{enumerate}

\subsubsection*{Алгоритм расшифрования}
\begin{enumerate}
    \item Пользователь A получает криптограмму $c$ от пользователя B.
    \item Пользователь A вычисляет $m = c^d \ mod \ n$.
\end{enumerate}

\textit{Замечание.} Для нахождения обратного элемента по модулю натурального числа применяется расширенный алгоритм Евклида.

\subsection*{Алгоритмы работы с большими числами}
Криптографические алгоритмы с открытым ключом при их использовании на практике оперируют числами большой битовой длины (или просто большими числами), когда речь идет о сотнях и тысячах бит. Для некоторых операцией над такими числами созданы специальные алгоритмы. В случае криптосистемы RSA необходимо иметь алгоритм, который позволит осуществлять быстрое возведение в степень по модулю. Данный алгоритм представлен ниже.

\subsubsection*{Алгоритм возведения в степень по модулю}
\begin{itemize}
    \item Вход: $a, k \in \mathbf{Z_n}, k = \sum\limits_{i=0}^{t} k_i \cdot 2^i.$
    \item Выход: $a^k \ mod \ n.$
    \begin{enumerate}
        \item $b = 1$. Если $k == 0$, то переход к шагу 5.
        \item $A = a$.
        \item Если $k_0 == 1$, то $b = a$.
        \item Для $i = \overline{1, t}$:
        \begin{itemize}
            \item $A = A^2 \ mod \ n$.
            \item Если $k_i == 1$, то $b = (A \cdot b) \ mod \ n$.
        \end{itemize}
        \item Вернуть b.
    \end{enumerate}
\end{itemize}

\subsubsection*{Простые числа}
Еще одним важным аспектом криптографии с открытым ключом является использование простых чисел, в частности, как было рассмотрено, в криптосистеме RSA элементом открытого ключа является произведение двух больших простых чисел 
Наиболее развитые вероятностные алгоритмы проверки чисел на простоту основаны на малой теореме Ферма.

\subsubsection*{Малая теорема Ферма}
Пусть $p$ — простое число, $a \neq 0$ и $a \in \mathbf{Z_p}$. Тогда $a^{p-1} \equiv 1 \ mod \ p$.

Соотношение, приведенное в теореме, используется в тесте, проверяющем, является ли заданное число составным. Этот тест называют тестом Ферма.

\subsubsection*{Тест Ферма}
\begin{itemize}
    \item Вход: нечетное число $n$
    \item Выход: $n$ — простое?
    \begin{enumerate}
        \item Для $i = \overline{1, t}$:
        \begin{itemize}
            \item Выбираем случайное целое число $a \in [2; n-1]$.
            \item Вычисляем $r = a^{n-1} \ mod \ n$ с помощью алгоритма возведения в степень по модулю.
            \item Если $r \neq 1$, то вернуть \verb|False|.
        \end{itemize}
        \item Вернуть \verb|True|.
    \end{enumerate}
\end{itemize}
Тест Ферма по основанию $a$ определяет простоту $n$ с вероятностью $\frac{1}{2}$, после $t$ итераций вероятность ошибки составляет $\frac{1}{2^t}$.




\subsection{Криптоанализ системы RSA}
Криптосистема RSA является достаточно стойкой, если в качестве ключа используются достаточно большие числа. В 2009 году исследователям удалось дешифровать сообщение, зашифрованное при помощи криптографического ключа стандарта RSA длиной 768 бит \cite{rsa:768}. Для этого были задействованы значительные вычислительные ресурсы.

Более выполнимыми оказываются атаки на RSA с неправильным подбором параметров (так называемые атака Хастада, атака Франклина-Рейтера) \cite{wiki:rsa_anal}.

\subsubsection{Бесключевое чтение RSA}
Рассмотрим атаку методом бесключевого чтения RSA \cite{rsa_attack}. Злоумышленник известны открытый ключ $(e,n)$ и шифротекст $c$. Злоумышленник должен найти такое число $j$, что $c^{e^j} \equiv c \ mod \ n $. Затем злоумышленник вычисляет $c^{e^{j - 1}} \ mod \ n $. Утверждается, что это и есть открытый текст $m$. В самом деле, согласно алгоритму зашифрования, $c = m^e \ mod \ n$. Видно, что $(c^{e^{j - 1}})^e \ mod \ n = c$, и значит $c^{e^{j - 1}}$ и есть $m$. 
\newpage



\section{Примеры шифрования}
\subsection{Зашифрование}
Зашифруем слово "Shadrunov" с помощью криптосистемы RSA. Представим его в битовом виде с помощью таблицы ASCII. 
\begin{gather*}
    X = \textnormal{Shadrunov} = \begin{pmatrix}
        083 & 104 & 097 & 100 & 114 & 117 & 110 & 111 & 118
    \end{pmatrix} = \\ = (
        1010011 \ | \ 1101000 \ | \ 1100001 \ | \ 1100100 \ | \ 1110010 \ | \ 1110101 \ | \ 1101110 \ | \ 1101111 \ | \ 1110110
    )
\end{gather*}
Выберем параметры шифрования:
\begin{enumerate}
    \item Пара простых чисел: $p = 31, q = 37$;
    \item Модуль алгоритма: $n = p \cdot q = 31 \cdot 37 = 1147$;
    \item Значение функции Эйлера: $\phi(n) = (31 - 1)(37 - 1) = 1080$;
    \item Экспонента зашифрования: $e = 17$;
    \item Экспонента расшифрования: $17 \cdot d \equiv 1 \ mod \ 1080, d = 953$;
\end{enumerate}
Открытый ключ $(e, n) = (17, 1147)$, закрытый ключ $(d, n) = (953, 1147)$.

Рассчитаем длину блока: $\lfloor \log_2 1147 \rfloor = 10$. Разобьём открытый текст на блоки: \linebreak $00000 00101 \ | \ 0011 1 10100 \ | \ 0 1100 001 11 \ | \ 00100  11100 \ | \ 10 111 0101 1 \ | \ 10111 0 1101\ |\ 111 11 10110$
Теперь переведём каждый блок в десятичный вид: $(5 \ | \ 244 \ | \ 391 \ | \ 156 \ | \ 747 \ | \ 749 \ | \ 1014)$.
Зашифруем каждый блок по формуле $c_i = m^e \ mod \ n$:
\begin{itemize}
    \item $c_1 = 5^{17} \ mod \ 1147 = 614$
    \item $c_2 = 244^{17} \ mod \ 1147 = 449$
    \item $c_3 = 391^{17} \ mod \ 1147 = 733$
    \item $c_4 = 156^{17} \ mod \ 1147 = 652$
    \item $c_5 = 747^{17} \ mod \ 1147 = 53$
    \item $c_6 = 749^{17} \ mod \ 1147 = 366$
    \item $c_7 = 1014^{17} \ mod \ 1147 = 291$
\end{itemize}
Выходная битовая последовательность: $(10011 00110 \ | \ 01110 00001 \ | \ 10110 11101 \ | \ 10100 01100 \ | \\ 00001 10101 \ | \ 01011 01110 \ | \ 01001 00011)$. Переведём в ASCII: $(76 \ | \ 103 \ | \ 3 \ | \ 55 \ | \ 52 \ | \ 48 \ | \ 26 \ | \ 86 \ | \\ 114 \ | \ 35) = (L  \ g \ ETX \ 7 \ 4 \ 0 \ DLE \ V \ r \ \#)$. Видно, что в результате появились не только символы английского алфавита, но и непечатные символы.


\subsection{Расшифрование}
Проделаем обратное преобразование ASCII-символов в битовую последовательность. Разобьём её на блоки по 10 бит. Каждый блок представим в виде десятичного числа (элемента кольца классов вычетов по модулю $n$). Получим: $(614 \ | \ 449 \ | \ 733 \ | \ 652 \ | \ 53 \ | \ 366 \ | \ 291)$. Теперь каждый элемент шифртекста расшифруем по формуле $m_i = c^d \ mod \ n$:
\begin{itemize}
    \item $m_1 = 614^{953} \ mod \ 1147 = 5$
    \item $m_2 = 449^{953} \ mod \ 1147 = 244$
    \item $m_3 = 733^{953} \ mod \ 1147 = 391$
    \item $m_4 = 652^{953} \ mod \ 1147 = 156$
    \item $m_5 = 53^{953} \ mod \ 1147 = 747$
    \item $m_6 = 366^{953} \ mod \ 1147 = 749$
    \item $m_7 = 291^{953} \ mod \ 1147 = 1014$
\end{itemize}
Выходная числовая последовательность: $(5 \ | \ 244 \ | \ 391 \ | \ 156 \ | \ 747 \ | \ 749 \ | \ 1014)$. Она совпадает с числовой последовательностью при зашифровании, то есть при представлении в виде ASCII-символов получаем "Shadrunov".
\newpage



\section{Программная реализация криптосистемы RSA}
Опишем особенности программной реализации криптосистемы RSA.
Реализация на языке Python {\bf доступна по ссылке} \href{https://github.com/shadrunov/mathmethods-labs/tree/lab4-rsa}{на GitHub}.

\subsection{Генерация ключей}
На вход программа получает длину простых чисел в битах. На выходе программа выдаёт параметры ключей: $e, n, d, p, q$. В качестве генератора простых чисел используется случайная битовая последовательность, которая затем проверяется на простоту с помощью теста Ферма \cite{medium:prime}.

Примеры генерации ключей представлен на рисунке 1.
\image{key.png}{Пример генерации ключей}{1}

\subsection{Зашифрование}
На вход программа получает открытый текст (поддерживаются символы ASCII), открытый ключ $(e, n)$. На выходе программа выдаёт шифртекст в виде символов ASCII, числа в десятичном и двоичном представлении. Важно учесть, что после зашифрования длина блока может превышать исходную, поэтому для хранения битовой записи блоков шифртекста используем увеличенную длину.

Пример зашифрования ручного примера представлен на рисунке 2.

\subsection{Расшифрование}
На вход программа получает шифртекст в виде символов ASCII или битовой последовательности (не все символы ASCII можно набрать на клавиатуре), закрытый ключ $(d, n)$. На выходе программа выдаёт открытый текст в виде символов ASCII, числа в десятичном и двоичном представлении. После расшифрования длину блока можно уменьшить на один, чтобы получить исходные последовательности.

Пример расшифрования ручного примера представлен на рисунке 2.

\image{1.png}{Пример шифрования ручного примера}{1}

Пример шифрования более длинной последовательности представлен на рисунках 3—4.
\image{2.png}{Генерация ключа и зашифрование длинной последовательности}{0.91}
\image{3.png}{Расшифрование длинной последовательности}{0.91}
\FloatBarrier
\clearpage



\section{Примеры криптоанализа}
Выполним простую атаку на криптосистему RSA: бесключевое чтение \cite{rsa_attack}. Для этого напишем скрипт \verb|crack.py|, последовательно возводящий шифртекст в степень $e$, пока не будет достигнуто совпадение с самим шифртекстом. Открытый текст при этом оказывается на предыдущей итерации. 

Пример зашифрования и дешифрования показан на рисунках 5 — 7.  
\image{4.png}{Генерация ключей и зашифрование символа "А"}{0.9}
\image{5.png}{Начало работы взломщика}{0.9}
\image{6.png}{Открытый текст найден на 869 итерации}{0.9}

Данная атака осуществима только при малых размерах ключа, иначе перебор займёт очень много времени.

\newpage



\section{Выводы о проделанной работе}
В данной работе мы изучили криптосистему RSA: генерацию ключей, алгоритмы зашифрования, расшифрования, а также алгоритмы для работы с большими числами (алгоритм возведения в степень по модулю) и с простыми числами (тест Ферма). Также удалось реализовать простую атаку — бесключевое чтение RSA. Эта атака, как и почти все известные атаки, осуществимы только при малых параметрах криптосистемы.

После выполнения работы стало ясно, что криптосистема RSA является стойкой при правильном выборе параметров. 
